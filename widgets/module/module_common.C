#include <string>
#include <iostream>
#include <sstream>
#include <ostream>
#include <fstream>
#include "module_common.h"

using namespace std;

namespace sight {
namespace common {

/****************
 ***** note *****
 **************** /

// Given a serialized representation of a note, returns an instance of the note 
// object that is encoded.
module::note module::note::deserialize(std::string serialized) {
  escapedStr es(serialized, ":", escapedStr::escaped);
  vector<string> fields = es.unescapeSplit();
  assert(fields.size()==2);
  // flagNote
  if(fields[0]=="fn") return flagNote(fields[1]);
  // Invalid note class
  assert(0);
}

// Creates a notes object from a ";"-separated list of serialized notes
module::notes::notes(std::string serialized) {
  escapedStr es(serialized, ";", escapedStr::escaped);
  vector<string> notes = es.unescapeSplit();
  for(vector<string>::iterator n=notes.begin(); n!=notes.end(); n++) {
    push_back(note::deserialize(*n));
  }
}
  */
/*******************
 ***** context *****
 *******************/

// Loads this context from the given properties map. The names of all the fields are assumed to be prefixed
// with the given string.
module::context::context(properties::iterator props, std::string prefix) {
  
  int numCfgKeys = properties::getInt(props, txt()<<prefix<<"numCfgKeys");
  for(int i=0; i<numCfgKeys; i++) {
    configuration[properties::get(props, txt()<<prefix<<"key_"<<i)] = 
                              attrValue(properties::get(props, txt()<<prefix<<"val_"<<i), attrValue::unknownT);
                                        //(attrValue::valueType)properties::getInt(props, txt()<<prefix<<"type_"<<i));
  }
}

// Adds the given key/attrValue pair to this context
void module::context::add(std::string key, const attrValue& val)
{ configuration[key] = val; }

// Add all the key/attrValue pairs from the given context to this one, overwriting keys as needed
void module::context::add(const context& that) {
  for(std::map<std::string, attrValue>::const_iterator c=that.configuration.begin(); c!=that.configuration.end(); c++)
    configuration[c->first] = c->second;
}

// Returns the properties map that describes this context object.
// The names of all the fields in the map are prefixed with the given string.
map<string, string> module::context::getProperties(std::string prefix) const {
  map<string, string> pMap;
  int i=0;
  pMap[txt()<<prefix<<"numCfgKeys"] = txt()<<configuration.size();
  for(std::map<std::string, attrValue>::const_iterator cfg=configuration.begin(); cfg!=configuration.end(); cfg++, i++) {
    pMap[txt()<<prefix<<"key_"<<i]  = cfg->first;
    pMap[txt()<<prefix<<"val_"<<i]  = cfg->second.serialize();
  }
  return pMap;
}

// Returns a human-readable string that describes this context
std::string module::context::str() const {
  ostringstream s;
  s << "[context :";
  for(map<string, attrValue>::const_iterator c=configuration.begin(); c!=configuration.end(); c++) {
    if(c!=configuration.begin()) s << " ";
    s << "("<<c->first<<": "<<c->second.getAsStr()<<")";
  }
  s << "]";
  return s.str();
}

// Returns a string encoding of the key information of a context attribute:
// moduleClass - the class that inherits from module that produced this attribute
// ctxtGrouping - the name of the grouping of context attributes within the attributes generated by the 
//    module class. This may be a given input (e.g. input0) or the configuration options of a compModule.
// attrName - the name of the context attribute itself.
std::string module::encodeCtxtName(const std::string& moduleClass, const std::string& ctxtGrouping, 
                                   const std::string& ctxtSubGrouping, const std::string& attrName) {
  return txt()<<escapedStr(moduleClass,  ":", escapedStr::unescaped).escape()<<":"<<
                escapedStr(ctxtGrouping, ":", escapedStr::unescaped).escape()<<":"<<
                escapedStr(ctxtSubGrouping, ":", escapedStr::unescaped).escape()<<":"<<
                escapedStr(attrName,     ":", escapedStr::unescaped).escape();
}

// Given a string encoded by encodeCtxtName(), sets moduleClass, ctxtGrouping and attrName to their original values
void module::decodeCtxtName(const std::string& encoded, 
                            std::string& moduleClass, std::string& ctxtGrouping, 
                            std::string& ctxtSubGrouping, std::string& attrName) {
  escapedStr e(encoded, ":", escapedStr::escaped);
  vector<string> fields = e.unescapeSplit(":");
  //cout << "encoded="<<encoded<<" #fields="<<fields.size()<<endl;
  assert(fields.size()>=2);
  moduleClass  = fields[0];
  ctxtGrouping = fields[1];
  if(fields.size()>=3) ctxtSubGrouping = fields[2];
  else                 ctxtSubGrouping = "";
  if(fields.size()>=4) attrName = fields[3];
  else                 attrName = "";
  // Remove any trailing line breaks
  if(attrName[attrName.length()-1] == '\n') attrName.erase(attrName.length()-1);
  if(attrName[attrName.length()-1] == '\r') attrName.erase(attrName.length()-1);
}

}; // namespace common
}; // namespace sight
